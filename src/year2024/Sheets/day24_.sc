import exts.*

import scala.annotation.tailrec

val s = "x00: 1\nx01: 0\nx02: 0\nx03: 1\nx04: 1\nx05: 1\nx06: 0\nx07: 0\nx08: 1\nx09: 1\nx10: 0\nx11: 1\nx12: 0\nx13: 1\nx14: 0\nx15: 1\nx16: 0\nx17: 0\nx18: 1\nx19: 1\nx20: 0\nx21: 0\nx22: 0\nx23: 1\nx24: 1\nx25: 1\nx26: 0\nx27: 0\nx28: 1\nx29: 0\nx30: 0\nx31: 0\nx32: 1\nx33: 0\nx34: 1\nx35: 0\nx36: 1\nx37: 0\nx38: 1\nx39: 1\nx40: 1\nx41: 0\nx42: 0\nx43: 0\nx44: 1\ny00: 1\ny01: 1\ny02: 1\ny03: 1\ny04: 0\ny05: 0\ny06: 0\ny07: 0\ny08: 0\ny09: 1\ny10: 0\ny11: 1\ny12: 0\ny13: 1\ny14: 0\ny15: 1\ny16: 1\ny17: 1\ny18: 1\ny19: 1\ny20: 0\ny21: 0\ny22: 1\ny23: 1\ny24: 1\ny25: 1\ny26: 0\ny27: 1\ny28: 0\ny29: 0\ny30: 0\ny31: 0\ny32: 1\ny33: 0\ny34: 1\ny35: 1\ny36: 0\ny37: 0\ny38: 0\ny39: 1\ny40: 1\ny41: 0\ny42: 0\ny43: 0\ny44: 1\n\nqgv OR dsf -> mjm\nshj AND wsr -> ftr\njcf OR wgg -> chb\njbp AND grd -> tcw\nrbm OR sck -> dtj\nqjb OR qqm -> vdr\nktf OR pvt -> tjg\nx32 XOR y32 -> wnj\nnbc AND wjv -> tjm\ny42 XOR x42 -> ksk\ny31 XOR x31 -> mqk\ny32 AND x32 -> jfp\ngrd XOR jbp -> z36\ny39 XOR x39 -> bmb\nvbj XOR chb -> z04\ntqv XOR www -> z40\nx34 AND y34 -> sck\ny07 AND x07 -> dsf\ny12 XOR x12 -> qvh\nfnt AND bnk -> pvt\nx10 XOR y10 -> fnt\nwgw AND nph -> hjt\nx30 XOR y30 -> bgs\nbdm XOR hvn -> z37\nmtg XOR vnm -> z06\ngdn OR pck -> wsr\nttr OR nfj -> fbv\njtn AND vtk -> wqs\nx08 XOR y08 -> qjb\ndmm OR mmr -> nhk\nqqd AND cph -> bqd\ntqv AND www -> nnr\nggg XOR kbg -> z03\nhff AND gdg -> twb\nnqm OR whj -> ghb\nx14 AND y14 -> nfj\ncrv XOR cvf -> z25\nftc OR jjn -> z45\nbnk XOR fnt -> z10\ny30 AND x30 -> mmr\nqtv AND dnj -> gbg\nx23 AND y23 -> vgr\nndd OR ncb -> fhg\nx33 AND y33 -> qgm\nrrh OR dqs -> gdp\ny40 XOR x40 -> www\nx41 XOR y41 -> wvq\njtn XOR vtk -> z20\ntpd OR djn -> qvc\ny18 AND x18 -> jdr\npnd OR hwf -> vtk\ny26 AND x26 -> vqh\nvcs XOR dtj -> jbp\nx03 AND y03 -> wgg\nrjv OR fgf -> brq\nvjn AND tjg -> trg\ncph XOR qqd -> z05\njbr AND ncd -> mvb\nqvh AND wmd -> fbn\nx25 XOR y25 -> cvf\nx39 AND y39 -> rvc\ny44 AND x44 -> ftc\ny36 XOR x36 -> grd\ny03 XOR x03 -> kbg\nvvj XOR bqv -> z27\nvbj AND chb -> kqr\ntwb OR dtd -> stw\nmnv XOR hcg -> z13\ny26 XOR x26 -> dnj\nrkd OR rmp -> wrw\ny22 XOR x22 -> tdc\nwvq AND tkt -> jsc\nmjm XOR gvw -> z08\nhvn AND bdm -> pck\ncbf XOR vdr -> z09\nhdb OR hmb -> qtv\ndvs OR mvd -> hwm\nmqk AND nhk -> ncb\nrfj OR jgc -> bst\nwrw XOR hwh -> z28\ngdp XOR stm -> z07\nstm AND gdp -> qgv\nhff XOR gdg -> z29\ny44 XOR x44 -> vbd\ntqq OR jjc -> tpn\nqgm OR mvb -> cqg\ndkg XOR ghb -> z02\nwrw AND hwh -> pkq\nhwm AND tdc -> z22\nx02 AND y02 -> gws\njfp OR mpd -> ncd\ny11 AND x11 -> smr\nhvd AND bmb -> vts\nkqr OR jsj -> qqd\ny24 XOR x24 -> wgw\nstw XOR bgs -> z30\ntpn AND wcn -> tpd\ny19 AND x19 -> pnd\ny38 AND x38 -> dkn\npkq OR vbc -> hff\ny31 AND x31 -> ndd\nwwc AND nvv -> whj\ny14 XOR x14 -> drk\nbst AND pkj -> jjc\nsht OR fhh -> bnk\nx05 XOR y05 -> cph\nvts OR rvc -> tqv\nx04 AND y04 -> jsj\nwjv XOR nbc -> z23\ny17 XOR x17 -> wcn\nx04 XOR y04 -> vbj\ny01 AND x01 -> nqm\nx01 XOR y01 -> wwc\nvdr AND cbf -> sht\njhm AND wst -> dvs\ntpv XOR drk -> z14\ncjm XOR rws -> z19\nbqd OR hns -> mtg\nx20 XOR y20 -> jtn\nx08 AND y08 -> gvw\ncbc XOR cqg -> z34\nrgt AND fbv -> rfj\nwmd XOR qvh -> z12\nx23 XOR y23 -> wjv\ny35 AND x35 -> ppf\nx43 AND y43 -> trf\nfhg XOR wnj -> z32\nx12 AND y12 -> cmn\ny00 AND x00 -> nvv\ntcw OR jms -> hvn\nnhk XOR mqk -> z31\nx07 XOR y07 -> stm\nvgr OR tjm -> nph\ndrk AND tpv -> ttr\nx09 AND y09 -> fhh\nx22 AND y22 -> snh\nwgw XOR nph -> z24\nmtg AND vnm -> rrh\nqvc AND mms -> tps\nx06 XOR y06 -> vnm\ntps OR jdr -> cjm\nfbv XOR rgt -> jgc\ny41 AND x41 -> wfd\nx19 XOR y19 -> rws\nhcg AND mnv -> cfk\nwsr XOR shj -> z38\nbrq AND jpt -> wtr\ncjm AND rws -> hwf\ny25 AND x25 -> hmb\ny02 XOR x02 -> dkg\ny40 AND x40 -> qsg\nbqv AND vvj -> rmp\nhvd XOR bmb -> z39\ny35 XOR x35 -> vcs\nx42 AND y42 -> rjv\nx37 AND y37 -> gdn\ntjg XOR vjn -> z11\nqtv XOR dnj -> z26\njhm XOR wst -> z21\nnwp OR gws -> ggg\ny00 XOR x00 -> z00\nmrq OR wqs -> wst\nx13 AND y13 -> rsq\nftr OR dkn -> hvd\njbr XOR ncd -> z33\nx05 AND y05 -> hns\nrsq OR cfk -> tpv\nmms XOR qvc -> z18\nx27 AND y27 -> rkd\ncrv AND cvf -> hdb\ncqg AND cbc -> rbm\npkj XOR bst -> z16\nx28 AND y28 -> vbc\njsc OR wfd -> ngw\nmjm AND gvw -> qqm\nwnj AND fhg -> mpd\ny15 XOR x15 -> rgt\nx20 AND y20 -> mrq\ntkt XOR wvq -> z41\ny13 XOR x13 -> mnv\ny24 AND x24 -> nqr\nwtr OR trf -> jvs\nggg AND kbg -> jcf\nx36 AND y36 -> jms\nx29 AND y29 -> dtd\nksk AND ngw -> fgf\nx11 XOR y11 -> vjn\ntpn XOR wcn -> z17\ny43 XOR x43 -> jpt\nvbd AND jvs -> jjn\nnnr OR qsg -> tkt\nx27 XOR y27 -> bqv\nx28 XOR y28 -> hwh\nx09 XOR y09 -> cbf\nvcs AND dtj -> qrg\nx34 XOR y34 -> cbc\nghb AND dkg -> nwp\ny37 XOR x37 -> bdm\nx38 XOR y38 -> shj\nhjt OR nqr -> crv\nvbd XOR jvs -> z44\nfbn OR cmn -> hcg\nx06 AND y06 -> dqs\ny15 AND x15 -> z15\nx33 XOR y33 -> jbr\ny21 XOR x21 -> jhm\nsnh OR drg -> nbc\ny18 XOR x18 -> mms\nvqh OR gbg -> vvj\ny21 AND x21 -> mvd\nqrg OR ppf -> z35\ny10 AND x10 -> ktf\nx16 AND y16 -> tqq\ntdc XOR hwm -> drg\nwwc XOR nvv -> z01\nx17 AND y17 -> djn\njpt XOR brq -> z43\nsmr OR trg -> wmd\nx16 XOR y16 -> pkj\nx29 XOR y29 -> gdg\nbgs AND stw -> dmm\nngw XOR ksk -> z42"

val Array(wireStr,gateStr) = s.split("\n\n")

type Wire = String

enum GateType:
  case AND, OR, XOR

  def apply(x: Int, y: Int): Int = this match
    case AND => x & y
    case OR => x | y
    case XOR => x ^ y

  def apply(s0: String, s1: String): String =
    Vector(s0, s1).sorted.mkString("(", s" $this ", ")")

object GateType:
  def unapply(s: String): Option[GateType] = Some(GateType.valueOf(s))

import GateType.*

case class Gate(g: GateType, w1: Wire, w2: Wire, out: Wire)

type Wires = Map[Wire,Int]
type Gates = Map[Wire,Gate]

val wires: Wires = wireStr.split("\n")
  .map{ case s"$wire: ${I(signal)}" => wire -> signal }.toMap
val gates: Gates = gateStr.split("\n")
  .map{ case s"$w1 $gate $w2 -> $out" => out -> Gate(GateType.valueOf(gate), w1, w2, out)}.toMap

extension (s: String)
  def pad(i: Long) = if i < 10 then s"${s}0$i" else s"$s$i"

case class Circuit(gates: Gates, inputs: Wires):
  def swap(out0: String, out1: String): Circuit =
    val (gate0, gate1) = (gates(out0), gates(out1))
    copy(gates = gates + (out0 -> gate1) + (out1 -> gate0))

  extension (s: String)
    def binary: Long =
      keys(s).foldRight(0L):
        case (key, acc) => (acc << 1) + exec(key, Set.empty)

  def z: Long = "z".binary
  
  def broken: Boolean = "x".binary + "y".binary != z

  def keys(prefix: String): Vector[String] =
    (inputs.keySet ++ gates.keySet).filter(_.startsWith(prefix)).toVector.sorted

  def exec(key: String, loop: Set[String]): Int =
    if loop(key) then -1
    else gates.get(key) match
      case Some(gate, i0, i1, _) => gate(exec(i0, loop + key), exec(i1, loop + key))
      case None                => inputs.getOrElse(key, -1)

  def circuit(key: String, loop: Set[String] = Set.empty): String =
    if loop(key) then ""
    else gates.get(key) match
      case Some(gate, i0, i1, _) => gate(circuit(i0, loop + key), circuit(i1, loop + key))
      case None                => key

  def inGates(key: String): Set[String] = gates.get(key) match
    case Some(_, i0, i1, _) => Set(key) ++ inGates(i0) ++ inGates(i1)
    case None               => Set.empty

  def carryBit(i: Int): String =
    val (x, y) = ("x".pad(i), "y".pad(i))
    if i == 0 then AND(x, y) else OR(AND(XOR(x, y), carryBit(i - 1)), AND(x, y))
  
  def addRes(i: Int): String =
    val (x, y) = ("x".pad(i), "y".pad(i))
    if i == 0 then XOR(x, y) else XOR(XOR(x, y), carryBit(i - 1))
  
  def fix(circuit: Circuit): Iterator[(Vector[String], Circuit)] =
    for
      key <- circuit.keys("z").iterator
      idx = key.tail.toInt
      adder = addRes(idx)
      if circuit.circuit(key) != adder
      key0 <- circuit.inGates(key)
      key1 <- circuit.gates.keySet
      newCircuit = circuit.swap(key0, key1)
      if newCircuit.circuit(key) == adder
    yield Vector(key0, key1) -> newCircuit
  
  def calc: Iterator[Vector[String]] =
    Iterator.unfold(this): circuit =>
      Option.when(circuit.broken)(fix(circuit).next())

Circuit(gates, wires).calc.flatten.toVector.sorted.mkString(",")